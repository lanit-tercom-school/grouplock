<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>jama_svd.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.5 on Mon Jan 20 07:47:17 2003 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>jama_svd.h</h1><a href="jama_svd_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#ifndef JAMA_SVD_H</font>
00002 <font class="preprocessor"></font><font class="preprocessor">#define JAMA_SVD_H</font>
00003 <font class="preprocessor"></font>
00004 
00005 <font class="preprocessor">#include "tnt_array1d.h"</font>
00006 <font class="preprocessor">#include "tnt_array1d_utils.h"</font>
00007 <font class="preprocessor">#include "tnt_array2d.h"</font>
00008 <font class="preprocessor">#include "tnt_array2d_utils.h"</font>
00009 <font class="preprocessor">#include "tnt_math_utils.h"</font>
00010 
00011 
00012 <font class="keyword">using</font> <font class="keyword">namespace </font>TNT;
00013 
00014 <font class="keyword">namespace </font>JAMA
00015 {
00033 template &lt;class Real&gt;
<a name="l00034"></a><a class="code" href="class_JAMA__SVD.html">00034</a> <font class="keyword">class </font>SVD 
00035 {
00036 
00037 
00038         Array2D&lt;Real&gt; U, V;
00039         Array1D&lt;Real&gt; s;
00040         <font class="keywordtype">int</font> m, n;
00041 
00042   <font class="keyword">public</font>:
00043 
00044 
<a name="l00045"></a><a class="code" href="class_JAMA__SVD.html#a0">00045</a>    <a class="code" href="class_JAMA__SVD.html#a0">SVD</a> (<font class="keyword">const</font> Array2D&lt;Real&gt; &amp;Arg)<font class="keyword"> </font>{
00046 
00047 
00048       m = Arg.dim1();
00049       n = Arg.dim2();
00050       <font class="keywordtype">int</font> nu = min(m,n);
00051       s = Array1D&lt;Real&gt;(min(m+1,n)); 
00052       U = Array2D&lt;Real&gt;(m, nu, Real(0));
00053       V = Array2D&lt;Real&gt;(n,n);
00054       Array1D&lt;Real&gt; e(n);
00055       Array1D&lt;Real&gt; work(m);
00056           Array2D&lt;Real&gt; A(Arg.copy());
00057       <font class="keywordtype">int</font> wantu = 1;                                    <font class="comment">/* boolean */</font>
00058       <font class="keywordtype">int</font> wantv = 1;                                    <font class="comment">/* boolean */</font>
00059           <font class="keywordtype">int</font> i=0, j=0, k=0;
00060 
00061       <font class="comment">// Reduce A to bidiagonal form, storing the diagonal elements</font>
00062       <font class="comment">// in s and the super-diagonal elements in e.</font>
00063 
00064       <font class="keywordtype">int</font> nct = min(m-1,n);
00065       <font class="keywordtype">int</font> nrt = max(0,min(n-2,m));
00066       <font class="keywordflow">for</font> (k = 0; k &lt; max(nct,nrt); k++) {
00067          <font class="keywordflow">if</font> (k &lt; nct) {
00068 
00069             <font class="comment">// Compute the transformation for the k-th column and</font>
00070             <font class="comment">// place the k-th diagonal in s[k].</font>
00071             <font class="comment">// Compute 2-norm of k-th column without under/overflow.</font>
00072             s[k] = 0;
00073             <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00074                s[k] = hypot(s[k],A[i][k]);
00075             }
00076             <font class="keywordflow">if</font> (s[k] != 0.0) {
00077                <font class="keywordflow">if</font> (A[k][k] &lt; 0.0) {
00078                   s[k] = -s[k];
00079                }
00080                <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00081                   A[i][k] /= s[k];
00082                }
00083                A[k][k] += 1.0;
00084             }
00085             s[k] = -s[k];
00086          }
00087          <font class="keywordflow">for</font> (j = k+1; j &lt; n; j++) {
00088             <font class="keywordflow">if</font> ((k &lt; nct) &amp;&amp; (s[k] != 0.0))  {
00089 
00090             <font class="comment">// Apply the transformation.</font>
00091 
00092                <font class="keywordtype">double</font> t = 0;
00093                <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00094                   t += A[i][k]*A[i][j];
00095                }
00096                t = -t/A[k][k];
00097                <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00098                   A[i][j] += t*A[i][k];
00099                }
00100             }
00101 
00102             <font class="comment">// Place the k-th row of A into e for the</font>
00103             <font class="comment">// subsequent calculation of the row transformation.</font>
00104 
00105             e[j] = A[k][j];
00106          }
00107          <font class="keywordflow">if</font> (wantu &amp; (k &lt; nct)) {
00108 
00109             <font class="comment">// Place the transformation in U for subsequent back</font>
00110             <font class="comment">// multiplication.</font>
00111 
00112             <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00113                U[i][k] = A[i][k];
00114             }
00115          }
00116          <font class="keywordflow">if</font> (k &lt; nrt) {
00117 
00118             <font class="comment">// Compute the k-th row transformation and place the</font>
00119             <font class="comment">// k-th super-diagonal in e[k].</font>
00120             <font class="comment">// Compute 2-norm without under/overflow.</font>
00121             e[k] = 0;
00122             <font class="keywordflow">for</font> (i = k+1; i &lt; n; i++) {
00123                e[k] = hypot(e[k],e[i]);
00124             }
00125             <font class="keywordflow">if</font> (e[k] != 0.0) {
00126                <font class="keywordflow">if</font> (e[k+1] &lt; 0.0) {
00127                   e[k] = -e[k];
00128                }
00129                <font class="keywordflow">for</font> (i = k+1; i &lt; n; i++) {
00130                   e[i] /= e[k];
00131                }
00132                e[k+1] += 1.0;
00133             }
00134             e[k] = -e[k];
00135             <font class="keywordflow">if</font> ((k+1 &lt; m) &amp; (e[k] != 0.0)) {
00136 
00137             <font class="comment">// Apply the transformation.</font>
00138 
00139                <font class="keywordflow">for</font> (i = k+1; i &lt; m; i++) {
00140                   work[i] = 0.0;
00141                }
00142                <font class="keywordflow">for</font> (j = k+1; j &lt; n; j++) {
00143                   <font class="keywordflow">for</font> (i = k+1; i &lt; m; i++) {
00144                      work[i] += e[j]*A[i][j];
00145                   }
00146                }
00147                <font class="keywordflow">for</font> (j = k+1; j &lt; n; j++) {
00148                   <font class="keywordtype">double</font> t = -e[j]/e[k+1];
00149                   <font class="keywordflow">for</font> (i = k+1; i &lt; m; i++) {
00150                      A[i][j] += t*work[i];
00151                   }
00152                }
00153             }
00154             <font class="keywordflow">if</font> (wantv) {
00155 
00156             <font class="comment">// Place the transformation in V for subsequent</font>
00157             <font class="comment">// back multiplication.</font>
00158 
00159                <font class="keywordflow">for</font> (i = k+1; i &lt; n; i++) {
00160                   V[i][k] = e[i];
00161                }
00162             }
00163          }
00164       }
00165 
00166       <font class="comment">// Set up the final bidiagonal matrix or order p.</font>
00167 
00168       <font class="keywordtype">int</font> p = min(n,m+1);
00169       <font class="keywordflow">if</font> (nct &lt; n) {
00170          s[nct] = A[nct][nct];
00171       }
00172       <font class="keywordflow">if</font> (m &lt; p) {
00173          s[p-1] = 0.0;
00174       }
00175       <font class="keywordflow">if</font> (nrt+1 &lt; p) {
00176          e[nrt] = A[nrt][p-1];
00177       }
00178       e[p-1] = 0.0;
00179 
00180       <font class="comment">// If required, generate U.</font>
00181 
00182       <font class="keywordflow">if</font> (wantu) {
00183          <font class="keywordflow">for</font> (j = nct; j &lt; nu; j++) {
00184             <font class="keywordflow">for</font> (i = 0; i &lt; m; i++) {
00185                U[i][j] = 0.0;
00186             }
00187             U[j][j] = 1.0;
00188          }
00189          <font class="keywordflow">for</font> (k = nct-1; k &gt;= 0; k--) {
00190             <font class="keywordflow">if</font> (s[k] != 0.0) {
00191                <font class="keywordflow">for</font> (j = k+1; j &lt; nu; j++) {
00192                   <font class="keywordtype">double</font> t = 0;
00193                   <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00194                      t += U[i][k]*U[i][j];
00195                   }
00196                   t = -t/U[k][k];
00197                   <font class="keywordflow">for</font> (i = k; i &lt; m; i++) {
00198                      U[i][j] += t*U[i][k];
00199                   }
00200                }
00201                <font class="keywordflow">for</font> (i = k; i &lt; m; i++ ) {
00202                   U[i][k] = -U[i][k];
00203                }
00204                U[k][k] = 1.0 + U[k][k];
00205                <font class="keywordflow">for</font> (i = 0; i &lt; k-1; i++) {
00206                   U[i][k] = 0.0;
00207                }
00208             } <font class="keywordflow">else</font> {
00209                <font class="keywordflow">for</font> (i = 0; i &lt; m; i++) {
00210                   U[i][k] = 0.0;
00211                }
00212                U[k][k] = 1.0;
00213             }
00214          }
00215       }
00216 
00217       <font class="comment">// If required, generate V.</font>
00218 
00219       <font class="keywordflow">if</font> (wantv) {
00220          <font class="keywordflow">for</font> (k = n-1; k &gt;= 0; k--) {
00221             <font class="keywordflow">if</font> ((k &lt; nrt) &amp; (e[k] != 0.0)) {
00222                <font class="keywordflow">for</font> (j = k+1; j &lt; nu; j++) {
00223                   <font class="keywordtype">double</font> t = 0;
00224                   <font class="keywordflow">for</font> (i = k+1; i &lt; n; i++) {
00225                      t += V[i][k]*V[i][j];
00226                   }
00227                   t = -t/V[k+1][k];
00228                   <font class="keywordflow">for</font> (i = k+1; i &lt; n; i++) {
00229                      V[i][j] += t*V[i][k];
00230                   }
00231                }
00232             }
00233             <font class="keywordflow">for</font> (i = 0; i &lt; n; i++) {
00234                V[i][k] = 0.0;
00235             }
00236             V[k][k] = 1.0;
00237          }
00238       }
00239 
00240       <font class="comment">// Main iteration loop for the singular values.</font>
00241 
00242       <font class="keywordtype">int</font> pp = p-1;
00243       <font class="keywordtype">int</font> iter = 0;
00244       <font class="keywordtype">double</font> eps = pow(2.0,-52.0);
00245       <font class="keywordflow">while</font> (p &gt; 0) {
00246          <font class="keywordtype">int</font> k=0;
00247                  <font class="keywordtype">int</font> kase=0;
00248 
00249          <font class="comment">// Here is where a test for too many iterations would go.</font>
00250 
00251          <font class="comment">// This section of the program inspects for</font>
00252          <font class="comment">// negligible elements in the s and e arrays.  On</font>
00253          <font class="comment">// completion the variables kase and k are set as follows.</font>
00254 
00255          <font class="comment">// kase = 1     if s(p) and e[k-1] are negligible and k&lt;p</font>
00256          <font class="comment">// kase = 2     if s(k) is negligible and k&lt;p</font>
00257          <font class="comment">// kase = 3     if e[k-1] is negligible, k&lt;p, and</font>
00258          <font class="comment">//              s(k), ..., s(p) are not negligible (qr step).</font>
00259          <font class="comment">// kase = 4     if e(p-1) is negligible (convergence).</font>
00260 
00261          <font class="keywordflow">for</font> (k = p-2; k &gt;= -1; k--) {
00262             <font class="keywordflow">if</font> (k == -1) {
00263                <font class="keywordflow">break</font>;
00264             }
00265             <font class="keywordflow">if</font> (abs(e[k]) &lt;= eps*(abs(s[k]) + abs(s[k+1]))) {
00266                e[k] = 0.0;
00267                <font class="keywordflow">break</font>;
00268             }
00269          }
00270          <font class="keywordflow">if</font> (k == p-2) {
00271             kase = 4;
00272          } <font class="keywordflow">else</font> {
00273             <font class="keywordtype">int</font> ks;
00274             <font class="keywordflow">for</font> (ks = p-1; ks &gt;= k; ks--) {
00275                <font class="keywordflow">if</font> (ks == k) {
00276                   <font class="keywordflow">break</font>;
00277                }
00278                <font class="keywordtype">double</font> t = (ks != p ? abs(e[ks]) : 0.) + 
00279                           (ks != k+1 ? abs(e[ks-1]) : 0.);
00280                <font class="keywordflow">if</font> (abs(s[ks]) &lt;= eps*t)  {
00281                   s[ks] = 0.0;
00282                   <font class="keywordflow">break</font>;
00283                }
00284             }
00285             <font class="keywordflow">if</font> (ks == k) {
00286                kase = 3;
00287             } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ks == p-1) {
00288                kase = 1;
00289             } <font class="keywordflow">else</font> {
00290                kase = 2;
00291                k = ks;
00292             }
00293          }
00294          k++;
00295 
00296          <font class="comment">// Perform the task indicated by kase.</font>
00297 
00298          <font class="keywordflow">switch</font> (kase) {
00299 
00300             <font class="comment">// Deflate negligible s(p).</font>
00301 
00302             <font class="keywordflow">case</font> 1: {
00303                <font class="keywordtype">double</font> f = e[p-2];
00304                e[p-2] = 0.0;
00305                <font class="keywordflow">for</font> (j = p-2; j &gt;= k; j--) {
00306                   <font class="keywordtype">double</font> t = hypot(s[j],f);
00307                   <font class="keywordtype">double</font> cs = s[j]/t;
00308                   <font class="keywordtype">double</font> sn = f/t;
00309                   s[j] = t;
00310                   <font class="keywordflow">if</font> (j != k) {
00311                      f = -sn*e[j-1];
00312                      e[j-1] = cs*e[j-1];
00313                   }
00314                   <font class="keywordflow">if</font> (wantv) {
00315                      <font class="keywordflow">for</font> (i = 0; i &lt; n; i++) {
00316                         t = cs*V[i][j] + sn*V[i][p-1];
00317                         V[i][p-1] = -sn*V[i][j] + cs*V[i][p-1];
00318                         V[i][j] = t;
00319                      }
00320                   }
00321                }
00322             }
00323             <font class="keywordflow">break</font>;
00324 
00325             <font class="comment">// Split at negligible s(k).</font>
00326 
00327             <font class="keywordflow">case</font> 2: {
00328                <font class="keywordtype">double</font> f = e[k-1];
00329                e[k-1] = 0.0;
00330                <font class="keywordflow">for</font> (j = k; j &lt; p; j++) {
00331                   <font class="keywordtype">double</font> t = hypot(s[j],f);
00332                   <font class="keywordtype">double</font> cs = s[j]/t;
00333                   <font class="keywordtype">double</font> sn = f/t;
00334                   s[j] = t;
00335                   f = -sn*e[j];
00336                   e[j] = cs*e[j];
00337                   <font class="keywordflow">if</font> (wantu) {
00338                      <font class="keywordflow">for</font> (i = 0; i &lt; m; i++) {
00339                         t = cs*U[i][j] + sn*U[i][k-1];
00340                         U[i][k-1] = -sn*U[i][j] + cs*U[i][k-1];
00341                         U[i][j] = t;
00342                      }
00343                   }
00344                }
00345             }
00346             <font class="keywordflow">break</font>;
00347 
00348             <font class="comment">// Perform one qr step.</font>
00349 
00350             <font class="keywordflow">case</font> 3: {
00351 
00352                <font class="comment">// Calculate the shift.</font>
00353    
00354                <font class="keywordtype">double</font> scale = max(max(max(max(
00355                        abs(s[p-1]),abs(s[p-2])),abs(e[p-2])), 
00356                        abs(s[k])),abs(e[k]));
00357                <font class="keywordtype">double</font> sp = s[p-1]/scale;
00358                <font class="keywordtype">double</font> spm1 = s[p-2]/scale;
00359                <font class="keywordtype">double</font> epm1 = e[p-2]/scale;
00360                <font class="keywordtype">double</font> sk = s[k]/scale;
00361                <font class="keywordtype">double</font> ek = e[k]/scale;
00362                <font class="keywordtype">double</font> b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;
00363                <font class="keywordtype">double</font> c = (sp*epm1)*(sp*epm1);
00364                <font class="keywordtype">double</font> shift = 0.0;
00365                <font class="keywordflow">if</font> ((b != 0.0) | (c != 0.0)) {
00366                   shift = sqrt(b*b + c);
00367                   <font class="keywordflow">if</font> (b &lt; 0.0) {
00368                      shift = -shift;
00369                   }
00370                   shift = c/(b + shift);
00371                }
00372                <font class="keywordtype">double</font> f = (sk + sp)*(sk - sp) + shift;
00373                <font class="keywordtype">double</font> g = sk*ek;
00374    
00375                <font class="comment">// Chase zeros.</font>
00376    
00377                <font class="keywordflow">for</font> (j = k; j &lt; p-1; j++) {
00378                   <font class="keywordtype">double</font> t = hypot(f,g);
00379                   <font class="keywordtype">double</font> cs = f/t;
00380                   <font class="keywordtype">double</font> sn = g/t;
00381                   <font class="keywordflow">if</font> (j != k) {
00382                      e[j-1] = t;
00383                   }
00384                   f = cs*s[j] + sn*e[j];
00385                   e[j] = cs*e[j] - sn*s[j];
00386                   g = sn*s[j+1];
00387                   s[j+1] = cs*s[j+1];
00388                   <font class="keywordflow">if</font> (wantv) {
00389                      <font class="keywordflow">for</font> (i = 0; i &lt; n; i++) {
00390                         t = cs*V[i][j] + sn*V[i][j+1];
00391                         V[i][j+1] = -sn*V[i][j] + cs*V[i][j+1];
00392                         V[i][j] = t;
00393                      }
00394                   }
00395                   t = hypot(f,g);
00396                   cs = f/t;
00397                   sn = g/t;
00398                   s[j] = t;
00399                   f = cs*e[j] + sn*s[j+1];
00400                   s[j+1] = -sn*e[j] + cs*s[j+1];
00401                   g = sn*e[j+1];
00402                   e[j+1] = cs*e[j+1];
00403                   <font class="keywordflow">if</font> (wantu &amp;&amp; (j &lt; m-1)) {
00404                      <font class="keywordflow">for</font> (i = 0; i &lt; m; i++) {
00405                         t = cs*U[i][j] + sn*U[i][j+1];
00406                         U[i][j+1] = -sn*U[i][j] + cs*U[i][j+1];
00407                         U[i][j] = t;
00408                      }
00409                   }
00410                }
00411                e[p-2] = f;
00412                iter = iter + 1;
00413             }
00414             <font class="keywordflow">break</font>;
00415 
00416             <font class="comment">// Convergence.</font>
00417 
00418             <font class="keywordflow">case</font> 4: {
00419 
00420                <font class="comment">// Make the singular values positive.</font>
00421    
00422                <font class="keywordflow">if</font> (s[k] &lt;= 0.0) {
00423                   s[k] = (s[k] &lt; 0.0 ? -s[k] : 0.0);
00424                   <font class="keywordflow">if</font> (wantv) {
00425                      <font class="keywordflow">for</font> (i = 0; i &lt;= pp; i++) {
00426                         V[i][k] = -V[i][k];
00427                      }
00428                   }
00429                }
00430    
00431                <font class="comment">// Order the singular values.</font>
00432    
00433                <font class="keywordflow">while</font> (k &lt; pp) {
00434                   <font class="keywordflow">if</font> (s[k] &gt;= s[k+1]) {
00435                      <font class="keywordflow">break</font>;
00436                   }
00437                   <font class="keywordtype">double</font> t = s[k];
00438                   s[k] = s[k+1];
00439                   s[k+1] = t;
00440                   <font class="keywordflow">if</font> (wantv &amp;&amp; (k &lt; n-1)) {
00441                      <font class="keywordflow">for</font> (i = 0; i &lt; n; i++) {
00442                         t = V[i][k+1]; V[i][k+1] = V[i][k]; V[i][k] = t;
00443                      }
00444                   }
00445                   <font class="keywordflow">if</font> (wantu &amp;&amp; (k &lt; m-1)) {
00446                      <font class="keywordflow">for</font> (i = 0; i &lt; m; i++) {
00447                         t = U[i][k+1]; U[i][k+1] = U[i][k]; U[i][k] = t;
00448                      }
00449                   }
00450                   k++;
00451                }
00452                iter = 0;
00453                p--;
00454             }
00455             <font class="keywordflow">break</font>;
00456          }
00457       }
00458    }
00459 
00460 
<a name="l00461"></a><a class="code" href="class_JAMA__SVD.html#a1">00461</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a1">getU</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>
00462 <font class="keyword">   </font>{
00463           <font class="keywordtype">int</font> minm = min(m+1,n);
00464 
00465           A = Array2D&lt;Real&gt;(m, minm);
00466 
00467           <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; i&lt;m; i++)
00468                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j=0; j&lt;minm; j++)
00469                         A[i][j] = U[i][j];
00470         
00471    }
00472 
00473    <font class="comment">/* Return the right singular vectors */</font>
00474 
<a name="l00475"></a><a class="code" href="class_JAMA__SVD.html#a2">00475</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a2">getV</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>
00476 <font class="keyword">   </font>{
00477           A = V;
00478    }
00479 
00481 
<a name="l00482"></a><a class="code" href="class_JAMA__SVD.html#a3">00482</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a3">getSingularValues</a> (Array1D&lt;Real&gt; &amp;x)<font class="keyword"> </font>
00483 <font class="keyword">   </font>{
00484       x = s;
00485    }
00486 
00490 
<a name="l00491"></a><a class="code" href="class_JAMA__SVD.html#a4">00491</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a4">getS</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>{
00492           A = Array2D&lt;Real&gt;(n,n);
00493       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00494          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00495             A[i][j] = 0.0;
00496          }
00497          A[i][i] = s[i];
00498       }
00499    }
00500 
00502 
<a name="l00503"></a><a class="code" href="class_JAMA__SVD.html#a5">00503</a>    <font class="keywordtype">double</font> <a class="code" href="class_JAMA__SVD.html#a5">norm2</a> ()<font class="keyword"> </font>{
00504       <font class="keywordflow">return</font> s[0];
00505    }
00506 
00508 
<a name="l00509"></a><a class="code" href="class_JAMA__SVD.html#a6">00509</a>    <font class="keywordtype">double</font> <a class="code" href="class_JAMA__SVD.html#a6">cond</a> ()<font class="keyword"> </font>{
00510       <font class="keywordflow">return</font> s[0]/s[min(m,n)-1];
00511    }
00512 
00516 
<a name="l00517"></a><a class="code" href="class_JAMA__SVD.html#a7">00517</a>    <font class="keywordtype">int</font> <a class="code" href="class_JAMA__SVD.html#a7">rank</a> ()<font class="keyword"> </font>
00518 <font class="keyword">   </font>{
00519       <font class="keywordtype">double</font> eps = pow(2.0,-52.0);
00520       <font class="keywordtype">double</font> tol = max(m,n)*s[0]*eps;
00521       <font class="keywordtype">int</font> r = 0;
00522       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; s.dim(); i++) {
00523          <font class="keywordflow">if</font> (s[i] &gt; tol) {
00524             r++;
00525          }
00526       }
00527       <font class="keywordflow">return</font> r;
00528    }
00529 };
00530 
00531 }
00532 <font class="preprocessor">#endif</font>
00533 <font class="preprocessor"></font><font class="comment">// JAMA_SVD_H</font>
</div></pre><hr><address><small>Generated at Mon Jan 20 07:47:17 2003 for JAMA/C++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.5 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
